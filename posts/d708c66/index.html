<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CTF-MISC杂项 | lyyourc</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="shortcut icon" href="/favicon.ico">
  
<link rel="stylesheet" href="/css/app.css">

  <!-- <link rel='stylesheet' href='http://fonts.useso.com/css?family=Source+Code+Pro'> -->
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <nav class="app-nav">
  
    
      <a href="/.">home</a>
    
  
    
      <a href="/archives">archive</a>
    
  
    
      <a href="/atom.xml">rss</a>
    
  
</nav>

  <main class="post">
  <article>
  <h1 class="article-title">
    <a href="/posts/d708c66/">CTF-MISC杂项</a>
  </h1>

  <section class="article-meta">
    <p class="article-date">September 02 2024</p>
  </section>

  <section class="article-entry">
    <h1 id="MISC-杂项"><a href="#MISC-杂项" class="headerlink" title="MISC 杂项"></a>MISC 杂项</h1><h2 id="文件的操作"><a href="#文件的操作" class="headerlink" title="文件的操作"></a>文件的操作</h2><h3 id="文件类型识别"><a href="#文件类型识别" class="headerlink" title="文件类型识别"></a>文件类型识别</h3><ol>
<li>file 命令	使用场景：不知道文件名，无法打开文件</li>
<li>winhex          使用场景：windows下通过文件头信息判断文件类型</li>
</ol>
<p>常见文件头、文件尾</p>
<table>
<thead>
<tr>
<th>文件格式</th>
<th>文件头</th>
<th>文件尾</th>
</tr>
</thead>
<tbody><tr>
<td>JPEG (jpg)文件头</td>
<td>FFD8FF</td>
<td>FF D9</td>
</tr>
<tr>
<td>PNG (png)文件头</td>
<td>89504E47</td>
<td>AE 42 60 82</td>
</tr>
<tr>
<td>GIF (gif) 文件头</td>
<td>47494638</td>
<td>00 3B</td>
</tr>
<tr>
<td>TIFF (tif)文件头</td>
<td>49492A00</td>
<td></td>
</tr>
<tr>
<td>XML (xml)文件头</td>
<td>3C3F786D6C</td>
<td></td>
</tr>
<tr>
<td>HTML (html)文件头</td>
<td>68746D6C3E</td>
<td></td>
</tr>
<tr>
<td>Adobe Acrobat (pdf)文件头</td>
<td>255044462D312E</td>
<td></td>
</tr>
<tr>
<td>ZIP Archive (zip)文件头</td>
<td>504B0304</td>
<td>504B</td>
</tr>
<tr>
<td>TAR （tar.gz）文件头</td>
<td>1F8B0800</td>
<td></td>
</tr>
<tr>
<td>RAR Archive (rar)文件头</td>
<td>526172211A0700 C43D7B00400700</td>
<td>C43D7B00400700</td>
</tr>
<tr>
<td>Wave (wav)文件头</td>
<td>57415645</td>
<td></td>
</tr>
<tr>
<td>AVI (avi)，文件头</td>
<td>41564920</td>
<td></td>
</tr>
<tr>
<td>MS Word&#x2F;Excel (xls.or.doc)文件头</td>
<td>D0CF11E0</td>
<td></td>
</tr>
<tr>
<td>Adobe Photoshop (psd)文件头</td>
<td>38425053</td>
<td></td>
</tr>
<tr>
<td>Windows Bitmap (bmp) 文件头</td>
<td>424D</td>
<td></td>
</tr>
</tbody></table>
<h3 id="文件分离"><a href="#文件分离" class="headerlink" title="文件分离"></a>文件分离</h3><ol>
<li>binwalk  工具</li>
</ol>
<p>用法：</p>
<ul>
<li>分析文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> binwalk filename</span><br></pre></td></tr></table></figure>

<ul>
<li>分离文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> binwalk -e filename</span><br></pre></td></tr></table></figure>

<ol>
<li>foremost 工具</li>
</ol>
<p>如果 binwalk 无法正确 分离出文件，可以使用该工具</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> foremost 文件名 -o 输出文件夹</span><br></pre></td></tr></table></figure>

<ol>
<li>dd</li>
</ol>
<p>当文件自动分离出错或者因为其他原因无法自动分离时，可以使用 dd 实现文件手动分离</p>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">dd</span> <span class="keyword">if</span>=源文件 of=目标文件名 bs=1 skip=开始分离的字节数</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if=file 	#输入文件名，缺省为标准输入</span><br><span class="line">of=file 	#输出文件名，缺省为标准输入</span><br><span class="line">bs=bytes	#同时设置读写块的大小为bytes，可代替ibs和obs</span><br><span class="line">skip=blocks	#从输入文件开头跳过blocks个块后再开始复制</span><br></pre></td></tr></table></figure>

<p><strong>方法二：可以尝试修改后缀名，但当隐藏了多种格式时可能会失败</strong></p>
<h3 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h3><ol>
<li>Linux 下的文件合并</li>
</ol>
<p>使用场景：linux 下，通常对文件名相似的文件要进行批量合并</p>
<p>格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 文件名1 文件名2 文件名3 &gt; 输出的文件</span><br></pre></td></tr></table></figure>

<p>完整性检测：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">md5sum</span> 文件名</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>windows 下的文件合并</li>
</ol>
<p>使用场景：windows 下，通常要对文件名相似的文件进行批量合并</p>
<p>格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy /B 合并的文件 输出的文件命令</span><br></pre></td></tr></table></figure>

<p>完整性检测：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil -hashfile 文件名 md5 </span><br></pre></td></tr></table></figure>

<h2 id="图片隐写"><a href="#图片隐写" class="headerlink" title="图片隐写"></a>图片隐写</h2><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p>​	首先使用 16进制编辑器 查看文件 或者使用 binwalk  有时 flag 会直接写在 里面</p>
<h3 id="LSB-隐写"><a href="#LSB-隐写" class="headerlink" title="LSB 隐写"></a>LSB 隐写</h3><ol>
<li>zsteg 工具</li>
</ol>
<p>使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zsteg xxxx.jpg</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>wbstego4 工具</li>
</ol>
<p>解密通过 lsb 加密的图片，bmp格式</p>
<p><img src="/posts/d708c66/1.png"></p>
<ol start="3">
<li>stegsolve</li>
</ol>
<p><img src="/posts/d708c66/aaaaa.png"></p>
<h3 id="文件CRC校验出错"><a href="#文件CRC校验出错" class="headerlink" title="文件CRC校验出错"></a>文件CRC校验出错</h3><p>图片 CRC 计算</p>
<p>TweakPNG</p>
<p><img src="/posts/d708c66/2.png"></p>
<p><img src="/posts/d708c66/32.png"></p>
<p>python -&gt; 计算文件宽高 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&quot;-f&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>, required=<span class="literal">True</span>,</span><br><span class="line">                 <span class="built_in">help</span>=<span class="string">&quot;输入同级目录下图片的名称&quot;</span>)</span><br><span class="line">args  = parser.parse_args()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bin_data = <span class="built_in">open</span>(args.f, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line">crc32key = zlib.crc32(bin_data[<span class="number">12</span>:<span class="number">29</span>]) <span class="comment"># 计算crc</span></span><br><span class="line">original_crc32 = <span class="built_in">int</span>(bin_data[<span class="number">29</span>:<span class="number">33</span>].<span class="built_in">hex</span>(), <span class="number">16</span>) <span class="comment"># 原始crc</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> crc32key == original_crc32: <span class="comment"># 计算crc对比原始crc</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;宽高没有问题!&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    input_ = <span class="built_in">input</span>(<span class="string">&quot;宽高被改了, 是否CRC爆破宽高? (Y/n):&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> input_ <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&quot;Y&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;&quot;</span>]:</span><br><span class="line">        exit()</span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(<span class="number">4095</span>), <span class="built_in">range</span>(<span class="number">4095</span>)): <span class="comment"># 理论上0x FF FF FF FF，但考虑到屏幕实际/cpu，0x 0F FF就差不多了，也就是4095宽度和高度</span></span><br><span class="line">            data = bin_data[<span class="number">12</span>:<span class="number">16</span>] + struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, i) + struct.pack(<span class="string">&#x27;&gt;i&#x27;</span>, j) + bin_data[<span class="number">24</span>:<span class="number">29</span>]</span><br><span class="line">            crc32 = zlib.crc32(data)</span><br><span class="line">            <span class="keyword">if</span>(crc32 == original_crc32): <span class="comment"># 计算当图片大小为i:j时的CRC校验值，与图片中的CRC比较，当相同，则图片大小已经确定</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;\nCRC32: <span class="subst">&#123;<span class="built_in">hex</span>(original_crc32)&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;宽度: <span class="subst">&#123;i&#125;</span>, hex: <span class="subst">&#123;<span class="built_in">hex</span>(i)&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;高度: <span class="subst">&#123;j&#125;</span>, hex: <span class="subst">&#123;<span class="built_in">hex</span>(j)&#125;</span>&quot;</span>)</span><br><span class="line">                exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python 文件名.py -f 图片</span><br></pre></td></tr></table></figure>

<h3 id="Exif隐写"><a href="#Exif隐写" class="headerlink" title="Exif隐写"></a>Exif隐写</h3><p>Exiftools</p>
<p><img src="/posts/d708c66/14.png"></p>
<h3 id="GIF-隐写"><a href="#GIF-隐写" class="headerlink" title="GIF 隐写"></a>GIF 隐写</h3><p>stegsole -&gt;  需要 java 环境</p>
<p><img src="/posts/d708c66/31.png"></p>
<p>逐帧查看</p>
<h3 id="bftools-工具"><a href="#bftools-工具" class="headerlink" title="bftools 工具"></a>bftools 工具</h3><p>使用场景：在 windows 的 cmd 下，对加密过的图片文件进行解密</p>
<p><img src="/posts/d708c66/15.png"></p>
<p>格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bftools decode braincopter 要解密的图片名称 -out 输出文件名</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bftools run 上一步输出的文件名称</span><br></pre></td></tr></table></figure>

<h3 id="silenteye-工具"><a href="#silenteye-工具" class="headerlink" title="silenteye 工具"></a>silenteye 工具</h3><p><img src="/posts/d708c66/16.png"></p>
<p>对音频或者图片解密</p>
<h3 id="Stegdetect-工具探测加密方式"><a href="#Stegdetect-工具探测加密方式" class="headerlink" title="Stegdetect 工具探测加密方式"></a>Stegdetect 工具探测加密方式</h3><p>根据探测到的加密方式，选择对应的工具破解</p>
<p>常见加密 : steg, Jphide, outguess, invisible secretc, f5 appendx 和 camouflage</p>
<p><img src="/posts/d708c66/18.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stegdetect 文件名</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stegdetect -s 敏感度 文件名</span><br></pre></td></tr></table></figure>

<h3 id="outguess-工具"><a href="#outguess-工具" class="headerlink" title="outguess 工具"></a>outguess 工具</h3><p>当 stegdetect 提示 outguess 加密时 </p>
<p><img src="/posts/d708c66/17.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outguess 要解密的文件名 输出结果文件名</span><br></pre></td></tr></table></figure>

<h3 id="JPhs-工具"><a href="#JPhs-工具" class="headerlink" title="JPhs 工具"></a>JPhs 工具</h3><p><img src="/posts/d708c66/19.png"></p>
<h3 id="F5"><a href="#F5" class="headerlink" title="F5"></a>F5</h3><p>使用场景，当 stegdetect 识别出来是F5 加密的图片</p>
<p>使用方法 ： 进入F5 -steganography_F5 目录 ,将 图片 拷贝 到给目录下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java extact 要解密的文件名 -p 密码</span><br></pre></td></tr></table></figure>

<h3 id="CQR-二维码处理"><a href="#CQR-二维码处理" class="headerlink" title="CQR 二维码处理"></a>CQR 二维码处理</h3><p><img src="/posts/d708c66/20.png"></p>
<h2 id="压缩文件处理"><a href="#压缩文件处理" class="headerlink" title="压缩文件处理"></a>压缩文件处理</h2><h3 id="伪加密"><a href="#伪加密" class="headerlink" title="伪加密"></a>伪加密</h3><p>如果压缩文件是加密的，或者文件头正常但是压缩错误，首先尝试问就按是否是伪加密。zip文件是否是加密，是通过标识符来显示的，在每个文件的文件目录字段有一位专门标识了文件是否加密，将其实设置为00表示该文件未加密，如果成功解压则文件为伪加密，如果解压出错说明文件为真加密，这时候就需要根据线索，或者使用工具来破解密码.</p>
<p><strong>如果是真加密也不用担心，密码一般都不会太复杂，而且一般都会给出密码位数（在爆破工具中要选择位数），它主要考察有没有暴力破解的工具和技术</strong></p>
<h4 id="zip-伪加密"><a href="#zip-伪加密" class="headerlink" title="zip 伪加密"></a>zip 伪加密</h4><p><img src="/posts/d708c66/25.png"></p>
<p>用 WinHex 或者 010editor 打开 文件 将 标识的两处 09 00 改成 00 00  保存文件</p>
<p><img src="/posts/d708c66/22.png"></p>
<p><img src="/posts/d708c66/23.png"></p>
<p><strong>注：如果修改错误或者是真加密，文件名后面会有 星号 （  *  ）或者打开错误</strong></p>
<h4 id="rar-伪加密"><a href="#rar-伪加密" class="headerlink" title="rar 伪加密"></a>rar 伪加密</h4><p>rar 文件由于有头部校验， 使用 伪加密时 打开文件会出现报错，使用winhex 修改标志位后如果报错消失且正常解压缩，说明是伪加密。使用winhex 打开rar 文件，找到第24个字节，该字节尾数为4 表示加密，0表示无加密，将尾数改为0即可破解伪加密</p>
<p><img src="/posts/d708c66/26.png"></p>
<h3 id="zip-密码破解"><a href="#zip-密码破解" class="headerlink" title="zip 密码破解"></a>zip 密码破解</h3><p>ziperello 工具</p>
<p><img src="/posts/d708c66/27.png"></p>
<h3 id="rar-密码破解"><a href="#rar-密码破解" class="headerlink" title="rar 密码破解"></a>rar 密码破解</h3><p>ARCHPR 工具</p>
<p><img src="/posts/d708c66/28.png"></p>
<p>如果知道密码的一部分可以选择使用掩码</p>
<h5 id="明文攻击"><a href="#明文攻击" class="headerlink" title="明文攻击"></a>明文攻击</h5><p>使用场景：已知加密的压缩文件中的铭文内容</p>
<p>例： 假设一个加密的压缩包中有两个文件 readme.txt 和 flag.txt，其中 flag.txt 的内容是我们希望知道的内容，而我们拥有readme.txt 的明文文件，使用上述两个文件可进行明文攻击</p>
<p>操作:</p>
<ol>
<li>将readme.txt 文件进行压缩，编程readme1.rar</li>
<li>打开 ARCHAR ，攻击类型选择明文，明文文件路径选择readme1.rar（j将明文文件不加密压缩后的文件），加密的文件</li>
<li>选择要破解的文件，点击开始，破解成功</li>
</ol>
<p><strong>注意： 使用该方法需要注意两个关键点</strong></p>
<ul>
<li>有一个明文文件，压缩后CRC值与加密压缩包中的文件一致</li>
<li>明文文件的压缩算法需要与加密压缩文件的压缩算法一致</li>
</ul>
<p><strong>有时候不一定能破解出文件口令，但是能够找到加密密钥等信息，可以直接将文件解密，点解确定保存解密后的文件即可</strong></p>
<p><img src="/posts/d708c66/30.png"></p>
<h2 id="流量分析-wireshark"><a href="#流量分析-wireshark" class="headerlink" title="流量分析 wireshark"></a>流量分析 wireshark</h2><p>流量分析中常用协议</p>
<ul>
<li>TCP</li>
<li>UDP</li>
<li>HTTP</li>
<li>TLS</li>
<li>HTTPS</li>
<li>USB</li>
<li>DNS</li>
<li>WIFI</li>
<li>ICMP</li>
<li>ARP</li>
</ul>
<p><img src="/posts/d708c66/3.png"></p>
<h3 id="流量包修复"><a href="#流量包修复" class="headerlink" title="流量包修复"></a>流量包修复</h3><h4 id="tshark"><a href="#tshark" class="headerlink" title="tshark"></a>tshark</h4><p>wireshark 的命令行版</p>
<p><img src="/posts/d708c66/4.png"></p>
<h3 id="协议分析"><a href="#协议分析" class="headerlink" title="协议分析"></a>协议分析</h3><h3 id="数据提取"><a href="#数据提取" class="headerlink" title="数据提取"></a>数据提取</h3><h4 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h4><h5 id="过滤ip"><a href="#过滤ip" class="headerlink" title="过滤ip"></a>过滤ip</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip.src eq x.x.x.x or ip.dst eq x.x.x.x 或 ip.addr eq x.x.x.x</span><br></pre></td></tr></table></figure>

<h5 id="过滤端口"><a href="#过滤端口" class="headerlink" title="过滤端口"></a>过滤端口</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcp.port eq 80 or udp.port eq 80</span><br><span class="line">tcp.dstport == 80 只显示tcp协议的目标端口为80 </span><br><span class="line">tcp.srcport == 80 只显示tcp协议的源端口为80</span><br><span class="line">tcp.port &gt;= 1 and tcp.port &lt;= 80</span><br></pre></td></tr></table></figure>

<h5 id="过滤协议"><a href="#过滤协议" class="headerlink" title="过滤协议"></a>过滤协议</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp/udp/arp/icmp/http/ftp/dns/ip</span><br></pre></td></tr></table></figure>

<h5 id="过滤mac"><a href="#过滤mac" class="headerlink" title="过滤mac"></a>过滤mac</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eth.dst == A0:00:00:04:C:84   过滤目标mac地址</span><br></pre></td></tr></table></figure>

<h5 id="包长度过滤"><a href="#包长度过滤" class="headerlink" title="包长度过滤"></a>包长度过滤</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udp.length == 26</span><br></pre></td></tr></table></figure>

<h5 id="USB流量分析"><a href="#USB流量分析" class="headerlink" title="USB流量分析"></a>USB流量分析</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tshark -r usb1.pcap -T fields -e usb.capdata &gt; usbdata.txt</span><br></pre></td></tr></table></figure>



<h4 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h4><ul>
<li>使用 Github 上一个大佬写的工具\<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Mumuzi7179/UsbKeyboard_Mouse_Hacker_Gui">https://github.com/Mumuzi7179/UsbKeyboard_Mouse_Hacker_Gui</a></li>
<li><img src="/posts/d708c66/Mouse_Key2.png"></li>
</ul>
</li>
</ul>
<ul>
<li>选择要提取的数据，选择键盘或者鼠标流量，将cap文件拖入程序中即可</li>
</ul>

  </section>
</article>

  <div class="sharing grid">
  <section class="profile grid-item grid">
    <img class="avatar" src="http://7xrcp8.com1.z0.glb.clouddn.com/avatar.png" alt="avatar" />
    <div class="grid-item">
      <p class="title"> lyyourc </p>
      <p class="subtitle"> You Are The JavaScript In My HTML </p>
    <div>
  </section>

  <section class="share-btns">
    <!-- <p> share it if you like it~ </p> -->
    <a
  class="twitter-share-button"
  data-size="large"
  data-via="DrakeLeung"
  target="_blank" rel="noopener" href="https://twitter.com/intent/tweet?text= id="MISC-杂项"><a hre"
>
  Tweet
</a>

<script>
  window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  js.async = true;
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));
</script>

  </section>
</div>


  
    
<section class="article-comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

<script>
  var disqus_shortname = 'drakeleung';
  
  var disqus_url = 'https://blog.lixey.top/posts/d708c66/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  
</main>

<script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>